#include "song.h"
#include "exception.h"
#include <cmath>

using namespace std;

//Constructors
Song::Song(int len, int key, bool ismajor, int tempo){
    Length = len;
    Key = key;
    IsMajor = ismajor;
    Tempo = tempo;
    TPQ = 120;
}

Song::Song(int key, bool ismajor){
    Key = key;
    IsMajor = ismajor;
    TPQ = 120;
}

Song::Song()
{
    TPQ = 120;
}

//Destructor
Song::~Song(){
    //for(auto& grade : Gradeprogression){
        //delete grade;
    //}
}


//Public functions
void Song::generate(){
    Scale scale(this->Key, this->IsMajor); //Generate the scale the song will be using
    Grade Tonic(1);         //make a Grade object with grade = 1
    Grade Dominant(5);

    int maxtries1 {10};     //maximum number of tries that the first grade can be reinitialised
    int iteration1 {0};
    bool loopstate1 {true}; //bool to "break" while loop
    while(loopstate1){
        try{
            Grade firstgrade;               //make a first grade object
            firstgrade.setchord(0,scale);   //set first grade
            this->Gradeprogression.push_back(firstgrade);
            for(int i = 0; i< this->Length; i++){       //procedurally generate all next grade objects
                int maxtries2 {10};     //number of tries to generate a next Grade object
                int iteration2 {0};
                bool loopstate2 {true}; //bool to "break" out of loop
                while(loopstate2){
                    try{
                        this->Gradeprogression.push_back(Gradeprogression[i].addgrade());       //make a grade object & push it back on gradeprogression
                        this->Gradeprogression.back().setchord(0,scale, Gradeprogression[i]);   //set the chord on the new grade object

                        loopstate2 = false;                                         //after succsessful generation break out of loop
                        cout<<"chord number " << i+1 << " has generated"<<endl;     //debug info
                    }catch(Exception_GradeProgression& e){      //catch errors generated by setchord
                        this->Gradeprogression.pop_back();      //remove last generated element
                        cout<< e.what() <<endl;                 //debug info
                        if(++iteration2 >= maxtries2){          //if it takes too many tries, error is thrown
                            if(i == 0){                         //If exception happens at the first chord after sufficient tries.
                                throw Exception_GradeInitialisation();
                            }
                            throw e;
                        }
                    }
                }
            }
            //finalisation, gradeprogression 5 - 1, Is susceptible for improvement.
            this->Gradeprogression.push_back(Dominant);
            this->Gradeprogression.back().setchord(0,scale,Gradeprogression[Gradeprogression.size() -2]);
            this->Gradeprogression.push_back(Tonic);
            this->Gradeprogression.back().setchord(0,scale,Gradeprogression[Gradeprogression.size()-2]);

            loopstate1 = false; //After successful completion, "break" out of loop
        }catch(Exception_GradeInitialisation& e){   //catch exception from line 64
            cout<< e.what() <<endl; //debug info
            if(++iteration1 >= maxtries1){
                throw e;    //is caught in mainwindow.cpp, error is displayed.
            }
        }
    }
}

void Song::solve_bassproblem(){
    Scale scale(this->Key, this->IsMajor); //Generate the scale the song will be using

    for(unsigned i = 0; i<Gradeprogression.size(); i++){ //loop through all grade objects in gradeprogression
        int maxtries {10};      //max number of tries to generate one chord
        int iteration {0};
        bool loopstate {true};
        while(loopstate){
            try{
                if(i == 0){Gradeprogression[i].setchord(1, scale);}                 //only for first grade: use setchord without grade argument
                else{Gradeprogression[i].setchord(1,scale, Gradeprogression[i-1]);} //generate chord on bassnote

                cout<<"chord number " << i+1 << " has generated"<<endl; //debug info
                loopstate = false;                                      //break ot of the loop if chord has generated successfully
            }catch(Exception_GradeProgression& e){  //catch errors
                if(i!=0){i-=1;}                 //if not faulty first chord, step back in the gradeprogression, else just try again
                cout<< e.what() <<endl;         //debug info
                if(++iteration >= maxtries){    //if it takes too many tries, error is thrown
                    throw e;
                }
            }
        }
    }
}

void Song::midiImportbass(string filename){
    smf::MidiFile midifile;
    midifile.read(filename);
    midifile.doTimeAnalysis();
    midifile.linkNotePairs();

    TPQ = midifile.getTicksPerQuarterNote();
    Tempo = 90;//midifile[0][0].getTempoBPM()*10;

    vector<int> notevals;
    vector<int> durations;
    vector<int> velocities;

    int tracks = midifile.getTrackCount();
    for (int track=0; track<tracks; track++) {
        for (int event=0; event<midifile[track].size(); event++) {
            if (midifile[track][event].isNoteOn()){
                durations.push_back(midifile[track][event].getTickDuration());
                notevals.push_back(midifile[track][event].getKeyNumber());
                velocities.push_back(midifile[track][event].getVelocity());
            }
        }
    }
    Scale scale(this->Key, this->IsMajor);
    for (unsigned i=0; i<notevals.size(); i++){
        //Code to figure out what notelength has to be assigned goes here
        cout<<TPQ * ((durations[i] + TPQ -1)/TPQ)<<' '<<TPQ<<endl;
        //cout<< TPQ*round(durations[i]/TPQ) <<endl;
        Gradeprogression.push_back(Grade(0,notevals[i], TPQ * ((durations[i] + TPQ -1)/TPQ), velocities[i], scale));
    }
}

void Song::midiExport(string filename){

    smf::MidiFile midifile;
    midifile.setTicksPerQuarterNote(TPQ);   //set tpq value
    midifile.addTimbre(0,0,0,0);            //track, atick, channel, instrument
    midifile.addTempo(0,0,this->Tempo);

    int timetick = 0;
    for(auto grade : Gradeprogression){ //do for all grades in the song
        for(int i = 0; i<grade.getnotecount();i++){ //for all notes of the chord
            Note note = grade.getnote(i);
            midifile.addNoteOn(0,timetick,0,note.getvalue(), note.getvelocity());
            midifile.addNoteOff(0, timetick + note.getlength(),0,note.getvalue());
            if(i == grade.getnotecount()-1){timetick+=note.getlength();} //add notelength to timetick after all notes of a chord have been written -> homophonic music
        }
    }
    midifile.sortTracks();  // sort tracks chronologically
    midifile.write(filename); //filename
    cout<<"written to "<<filename<<endl;
}

void Song::printgradeprogression(){
    for(auto& grade : this->Gradeprogression){
        grade.print();
    }
}
